#!/usr/bin/env python
# -*- coding: utf-8 -*-

#####################################
#                                   #
# process_str.py                    #
#                                   #
# Reads in *.str file generated by  #
# Suprem4.gs.                       #
#                                   #
# Taylor Shin, Apr 05 2016          #
#                                   #
#####################################

import os
import sys
import re

"""@A little tool to extract data tokens from
a line of Suprem str file.
"""
# Extract list
def extr_list(space_sep_list):
    s = re.sub('\s+', ' ', space_sep_list).strip()
    return s.split(' ')[1:]

"""@Material Map
--> Returns material as string when referenced by integer code.

"""
Material_Map = {
    0: "Gas",
    1: "SiO2",
    2: "SiNi",
    3: "Si",
    4: "Poly",
    5: "OxNi",
    6: "Al",
    7: "Photoresist",
    8: "GaAs",
}

"""@GasMaterial Map
--> Returns Gas type as string.
"""
GasMaterial_Map = {
    1: "Argon",
    10: "Dry O2",
    11: "Wet O2",
    4: "Gas Sb",
    2: "Gas As",
    5: "Gas B",
    3: "Gas P",
    31: "Gas Be",
    33: "Gas Mg",
    35: "Gas Se",
    37: "Gas Si",
    39: "Gas Sn",
    41: "Gas Ge",
    43: "Gas Zn",
    45: "Gas C",
    47: "Gas Generic",
}

"""@Impurity Map
--> Returns impurity element as string
"""
Impurity_Map = {
    0: "Vacancies",
    1: "Interstitials",
    2: "Arsenic",
    3: "Phosphorus",
    4: "Antimony",
    5: "Boron",
    6: "Electron",
    7: "Hole",
    8: "X velocity",
    9: "Y velocity",
    10: "Dry O2",
    11: "Wet O2",
    12: "Interstitial Traps",
    13: "Gold",
    14: "Potential",
    15: "Sxx",
    16: "Syy",
    17: "Sxy",
    18: "Cesium Oxide Charge",
    19: "Intreface Charge",
    20: "Arsenic Active",
    21: "Phosphorus Active",
    22: "Antimony Active",
    23: "Boron Active",
    24: "Polysilicon Grain Size",
    25: "P-type tracer (miyake)",
    26: "",
    31: "Beryllium",
    32: "Berylllium Active",
    33: "Magnesium",
    34: "Magnesium Active",
    35: "Selenium",
    36: "Selenium Active",
    37: "Silicon (impurity)",
    38: "Silicon (impurity) Active",
    39: "Tin",
    40: "Tin Active",
    41: "Germanium",
    42: "Germanium Active",
    43: "Zinc",
    44: "Zinc Active",
    45: "Carbon",
    46: "Carbon Active",
    47: "Generic",
    48: "Generic Active",
}

"""@Orientation Map
"""
Orienetation_Map = {
    0: "100",
    1: "110",
    2: "111",
}


"""@The structure file reader library
"""
class Reader(object):

    """@The constructor
    """
    def __init__(self, filename=None):
        if not filename:
            print("Reader: No Suprem4 structure file given!!!")
            sys.exit(-1)

        # Initialize the input file
        self.str_file = os.path.abspath(filename)

        # Stores the structure file content line by line
        self.line_data = []           # Node coordinates

        self.Dimension = 0            # Number of dimensions
        self.nVertices = 0            # Number of Vertices
        self.nEdges = 0               # Number of Edges

        self.version = ""             # Version string
        self.curr_line = ""           # Current line (temprary constant)

        # Solver parameters
        self.solver_params = {}       # Some mathematical magic constants

        # Reader settings
        self.reader_entries = 0       # Reader entry number
        self.reader_entry_list = []   # Reader entry list

        # Stores node information
        self.RegionMat = {}           # Material definition
        self.Triangles = {}           # List of triangels --> not used for now
        self.index_list = []          # Node number list
        self.coord_list = []          # Node coordinate list
        self.Cal_data = []            # Calculation data list
        self.Impurity_columns = ()    # Impurity at specified column in Cal_data

        self.Nodes = []               # Collection of nodes

        # Now, read in str file and populate nodes
        self.str_file_read()

    """@Structure file reader
    """
    def str_file_read(self):
        """@Data Reader map by datatype
        """
        Data_Reader_Map = \
            {
                "v": self.Version_reader,
                "D": self.Dimension_reader,
                "c": self.Linedata_reader,
                "r": self.Region_reader,
                "t": self.Triangle_reader,
                "M": self.Parameter_reader,
                "s": self.Set_reader,
                "n": self.Data_reader,
                "I": self.Impurity_reader,
            }

        # Extract line by line
        with open(self.str_file) as fp:
            self.line_data = fp.readlines()

        # Sort data by type
        for line in self.line_data:
            self.curr_line = line
            Data_Reader_Map[line[0]]()

        # Re-arrange data as class Node objects.
        num_o_nodes = [n[0] for n in self.Cal_data]
        for c_i, coord in enumerate(self.coord_list):
            cal_data = self.find_cal_data(self.index_list[c_i])

            if cal_data:
                dopant_info = \
                    Dopants(self.reader_entry_list, cal_data[2])
                new_Node = \
                    Node(coord=coord,
                        index=cal_data[0],
                        material=cal_data[1],
                        doping=dopant_info)
                # Now populate nodes.
                self.Nodes.append(new_Node)

        # Write summary output
        string_node_status = \
            "\n"+\
            "Structure file   : "+str(self.str_file)+"\n"+\
            "Number of Nodes  : "+str(len(self.Nodes))+"\n"+\
            "Model Dimension  : "+str(self.Dimension)+"\n"+\
            "Region Materials : "+str(self.RegionMat)+"\n"+\
            "Dopant Types     : "+str(self.reader_entry_list)+"\n"+\
            "\n"
        print(string_node_status)

    """@Return the Nodes
    """
    def GetNodes(self):
        return self.Nodes

    """@Find cal data with node number
    """
    def find_cal_data(self, node_number):
        cal_data_node_numbers = []
        for cd in self.Cal_data:
            cal_data_node_numbers.append(cd[0])

        if (node_number in cal_data_node_numbers):
            for icd, cd in enumerate(self.Cal_data):
                if cd[0] == 0 or cd[0] == '0':
                    pass
                else:
                    if node_number == cd[0]:
                        return cd
        else:
            return None

    """@str file reader method collection.
        Each method will be called line by line to process
        a string that temporary stored at self.curr_line.
    """
    """@Version
    """
    def Version_reader(self):
        self.version = ' '.join(extr_list(self.curr_line))

    """@Dimension
    """
    def Dimension_reader(self):
        dim_str_list = extr_list(self.curr_line)
        self.Dimension = int(dim_str_list[0])
        self.nVertices = int(dim_str_list[1])
        self.nEdges = int(dim_str_list[2])

    """@Linedata
    """
    def Linedata_reader(self):
        lin_data_list = extr_list(self.curr_line)[:-1]
        # [:-2] --> Omitting last 0

        self.index_list.append(int(lin_data_list[0]))
        coord_string_list = lin_data_list[1:]
        coord_data = []
        for csl in coord_string_list:
            coord_data.append(float(csl))
        self.coord_list.append(tuple(coord_data))

    """@Region
    """
    def Region_reader(self):
        reg_list = extr_list(self.curr_line)
        self.RegionMat[int(reg_list[0])] = \
            Material_Map[int(reg_list[1])]

    """@Triangle
    """
    def Triangle_reader(self):
        tri_list = extr_list(self.curr_line)
        # for now, we don't need triangles.
        # So, this is just a dummy method.

    """@Parameter
    """
    def Parameter_reader(self):
        param_list = extr_list(self.curr_line)
        self.solver_params['SubOri']        = int(param_list[0])
        self.solver_params['LastTemp']      = float(param_list[1])
        self.solver_params['RadDislocLoop'] = float(param_list[2])
        self.solver_params['DenDislocLoop'] = float(param_list[3])

    """@Settings
    """
    def Set_reader(self):
        set_list = extr_list(self.curr_line)
        self.reader_entries = int(set_list[0])
        for sl in set_list[1:]:
            self.reader_entry_list.append(Impurity_Map[int(sl)])

    """@Data
    """
    def Data_reader(self):
        data_list = extr_list(self.curr_line)
        node_num = int(data_list[0])
        material = Material_Map[int(data_list[1])]
        cal_results = []
        for dl in data_list[2:]:
            cal_results.append(float(dl))
        self.Cal_data.append([node_num, material, cal_results])

    """@Impurity
    """
    def Impurity_reader(self):
        imp_list = extr_list(self.curr_line)
        imp_col = []
        for ind_il, il in enumerate(imp_list[1:]):
            n_il = int(il)
            if n_il:
                imp_col.append(ind_il)
        self.Impurity_columns = tuple(imp_col)

"""@A class for a node data information.
"""
class Node(object):
    """@The constructor
    """
    def __init__(self,
            coord=None,
            index=0,
            material=None,
            doping={}):
        self.coordinate = coord
        self.index = index
        self.material = material
        self.impurity = doping
        self.triangle_map = []

    """@Returns if 1D, 2D, or 3D
    """
    def Dimension(self):
        return len(self.coordinate)

    """@Set Coordinate
    """
    def SetCoord(self, coords):
        self.coordinate = tuple(coords)

    """@Set index
    """
    def SetIndex(self, new_index):
        self.index = int(new_index)

    """@Set triangle
    """
    def SetTriangle(self, triangle_map):
        if (len(triangle_map) == 4):
            self.triangle_map = triangle_map

    """@Set doping
    """
    def SetDoping(self, dopant_class):
        self.impurity = dopant_class

    """@Set material
    """
    def SetMaterial(self, Material):
        if isinstance(Material, str):
            self.material = Material
        elif isinstance(Material, int):
            self.material = Material_Map[Material]

    """@Get coordinates
    """
    def GetCoord(self):
        return self.coordinate

    """@Returns doping by Impurity tuple.
    """
    def GetDoping(self, index=()):
        doping_conc = []
        if index:
            for i in index:
                doping_conc.append(list(self.impurity.GetDoping(i)))
            return doping_conc
        else:
            return self.impurity.GetAll()

    """@Returns number of impurities
    """
    def GetNumOImpurities(self):
        return self.impurity.NumberOfDopants()

    """@Returns dopant list
    """
    def GetDopants(self):
        return self.impurity.GetDopants()

    """@Returns doping concentration
    """
    def GetDopConc(self, dop_index=None):
        if not dop_index:
            return self.impurity.GetDopConc()
        else:
            return self.impurity.GetDopConc(dop_index)

"""@Another storage class that contains dopant information for
    a Node class
"""
class Dopants(object):
    """@Constructor
    """
    def __init__(self, dopants, doping_conc):
        self.dopant_list = dopants
        self.doping_conc = doping_conc

    """@Returns dopants and concentration info
        as a dictionary
    """
    def GetAll(self):
        ret_dict = {}
        for dop_ind, dop in enumerate(self.doping_conc):
            ret_dict[dop] = self.doping_conc[dop_ind]
        return ret_dict

    """@Returns dopant list
        --> if supplied with colum number
        (Impurity_columns in Reader class)
    """
    def GetDopants(self, index=None):
        if not index:
            return self.dopant_list
        else:
            return self.dopant_list[index-1]

    """@Returns doping concentration list
        --> if supplied with colum number
        (Impurity_columns in Reader class)
    """
    def GetDopConc(self, index=None):
        if not index:
            return self.doping_conc
        else:
            return self.doping_conc[index-1]

    """@Returns dopant-doping conc pair by index
    """
    def GetDoping(self, index=None):
        if not index:
            return self.GetAll()
        else:
            return self.GetDopants(index), self.GetDopConc(index)

    """@Returns number of entries
    """
    def NumberOfDopants(self):
        return len(self.dopant_list)
